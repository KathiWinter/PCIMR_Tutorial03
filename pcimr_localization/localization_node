#!/usr/bin/env python3

import rospy
import numpy as np
import time
from std_msgs.msg import String
from sensor_msgs.msg import LaserScan
from nav_msgs.msg import OccupancyGrid, MapMetaData
from geometry_msgs.msg import Point
from visualization_msgs.msg import Marker


class LocalizationNode():

    def __init__(self):

        global move
        move = None
        global scan 
        scan = None
        global grid 
        grid = None
        global msg_map
        msg_map = None


        # Initialize Subscribers
        self.sub_move = rospy.Subscriber('/move', String, self.callback_move)
        self.sub_scan = rospy.Subscriber('/scan', LaserScan, self.callback_scan)
        self.sub_map = rospy.Subscriber('/map', OccupancyGrid, self.callback_grid)

        # Initialize Publishers
        self.pub_pos = rospy.Publisher("/robot_pos", Point, queue_size=10)
        self.pub_marker = rospy.Publisher("/visualization/robot_pos", Marker, queue_size=10)
        self.pub_grid = rospy.Publisher("/robot_pos_map", OccupancyGrid, queue_size=10)


        self.belief = []


    def callback_move(self, param_move):
        global move
        move = param_move
        
    def callback_scan(self, param_scan):
        global scan 
        scan = param_scan

    def callback_grid(self, param_grid):
        global grid
        global msg_map
        grid = param_grid

        msg_map = OccupancyGrid()
        msg_map.header.frame_id = grid.header.frame_id
        msg_map.header.seq = grid.header.seq
        msg_map.info.map_load_time = rospy.Time.now()
        msg_map.info.resolution = grid.info.resolution
        msg_map.info.height = grid.info.height
        msg_map.info.width = grid.info.width

        self.bayes_filter(grid)

    def bayes_filter(self,grid):
        global msg_map
        global move
        global scan
   
        probabilities = self.belief
        
        #Initialize first probability array
        if(len(self.belief) == 0):

            #Count accessible field[0]s 
            fields = 0
            for field in enumerate(grid.data):
                if field[1] == 0:
                    fields += 1

        
            #Probability of being kidnapped randomly to one field, for each field
            self.ptx = 1/fields

            probabilities = np.transpose(np.asarray(grid.data, dtype=np.float).reshape(grid.info.width, grid.info.height))
            for field in enumerate(grid.data):
                y, x = divmod(field[0], 20)
                if field[1] != 0: 
                    probabilities[y][x] = 0
                else: 
                    probabilities[y][x] = self.ptx
        
        sum_p = 0

        for field in enumerate(grid.data):
            y, x = divmod(field[0], 20)
            #Incoporate the move-model

            move_uncertainty = np.array([0.9,0.04,0.04,0.0,0.02])
            if(move != None):
                self.ptx_1 = 0
                self.ptx_2 = 0
                self.ptx_3 = 0
                self.ptx_4 = 0
                if(probabilities[y][x] == 0):
                    pass
                elif(move.data == "N"):
                    if(y-1 > 0):
                        self.ptx_1 = probabilities[y-1][x]
                    if(x+1 < 20):
                        self.ptx_2 = probabilities[y][x+1]
                    if(x-1 > 0):
                        self.ptx_3 = probabilities[y][x-1]
                    if(y+1 < 20):
                        self.ptx_4 = probabilities[y+1][x]
                elif(move.data == "S"):
                    if(y+1 < 20):
                        self.ptx_1 = probabilities[y+1][x]
                    if(x-1 > 0):
                        self.ptx_2 = probabilities[y][x-1]
                    if(x+1 < 20):
                        self.ptx_3 = probabilities[y][x+1]
                    if(y-1 > 0):
                        self.ptx_4 = probabilities[y-1][x]
                elif(move.data == "E"):
                    if(x-1 > 0):
                        self.ptx_1 = probabilities[y][x-1]
                    if(y-1 > 0):
                        self.ptx_2 = probabilities[y-1][x]
                    if(y+1 < 20):
                        self.ptx_3 = probabilities[y+1][x]
                    if(x+1 < 20):
                        self.ptx_4 = probabilities[y][x+1]
                elif(move.data == "W"):
                    if(x+1 < 20):
                        self.ptx_1 = probabilities[y][x+1]
                    if(y+1 < 20):
                        self.ptx_2 = probabilities[y+1][x]
                    if(y-1 > 0):
                        self.ptx_3 = probabilities[y-1][x]
                    if(x-1 > 0):
                        self.ptx_4 = probabilities[y][x-1]
                else:
                    print("error receiving directions")

                p_bel1 = np.dot(move_uncertainty, [self.ptx_1, self.ptx_2, self.ptx_3, self.ptx_4, probabilities[y][x]])
              
            else: 
                p_bel1 = probabilities[y][x]
         
            #Incoroporate sensor model
            #[2.0, 2.0, 10.0, 2.0] S, W, N, E
            if(scan == None):
                pass
            else:
    
                n = None
                s = None
                w = None
                e = None
                #South Sensor
                if(field[0]-grid.info.width*int(scan.ranges[0]+1) >= 0):
                    if(grid.data[field[0]-grid.info.width*int(scan.ranges[0])] ==  100):
                        s = 0.8
                    elif(grid.data[field[0]-grid.info.width*int(scan.ranges[0]+1)] == 100 or grid.data[field[0]-grid.info.width*int(scan.ranges[0]-1)] == 100):
                        s = 0.1
                    else: 
                        s = 0.0
                
                #West Sensor
                if(field[0]-1*int(scan.ranges[1]+1)>=0):       
                    if(grid.data[field[0]-1*int(scan.ranges[1])] == 100):
                        w = 0.8
                    elif(grid.data[field[0]-1*int(scan.ranges[1]+1)] == 100 or grid.data[field[0]-1*int(scan.ranges[1]-1)] == 100):
                        w = 0.1
                    else: 
                        w = 0.0

                #North Sensor
                if(field[0]+grid.info.width*int(scan.ranges[2]+1)<len(grid.data)):
                    if(grid.data[field[0]+grid.info.width*int(scan.ranges[2])] == 100):
                        n = 0.8
                    elif(grid.data[field[0]+grid.info.width*int(scan.ranges[2]+1)] == 100 or grid.data[field[0]+grid.info.width*int(scan.ranges[2]-1)] == 100):
                        n = 0.1
                    else: 
                        n = 0.0
                
                #East Sensor
                if(field[0]+1*int(scan.ranges[3]+1) < len(grid.data)):
                    if(grid.data[field[0]+1*int(scan.ranges[3])] == 100):
                        e = 0.8
                    elif(grid.data[field[0]+1*int(scan.ranges[3]+1)] == 100 or grid.data[field[0]+1*int(scan.ranges[3]-1)] == 100):
                        e = 0.1
                    else: 
                        e = 0.0
     
            if(n != None and s != None and e != None and w != None):
                p_bel2 = (n + s + e + w) * p_bel1
                if(n == 0 or s == 0 or e == 0 or w == 0):
                    p_bel2 = 0.0
            else: 
                p_bel2 = p_bel1
            
            sum_p += p_bel2
           
            y, x= divmod(field[0], 20)
            probabilities[y][x] = p_bel2
            #END FOR-LOOP
        
        n = 1 / sum_p

        for indexp, r in enumerate(probabilities):
            for indexx, p in enumerate(r):
                probabilities[indexp][indexx] = p * n
                
        
        max = 0
        self.max_point = (0,0)
        for indexi, i in enumerate(probabilities):
            for indexx, x in enumerate(i):
                if x > max:
                    max = x
                    self.max_point = (indexx, indexi)
        
 
        msg_map = self.numpy_to_occupancy_grid(probabilities)
        print(msg_map)
        
        self.belief = probabilities

    def numpy_to_occupancy_grid(self, arr, info=None):
        if not len(arr.shape) == 2:
            raise TypeError('Array must be 2D')

        # Adjust values
        arr = arr.astype('float64')
        factor = 100/np.max(arr)
        arr[arr > 0] *= factor

        arr = np.array(np.transpose(arr), dtype=np.int8)

        grid = OccupancyGrid()
        if isinstance(arr, np.ma.MaskedArray):
            # We assume that the masked value are already -1, for speed
            arr = arr.data
        grid.data = arr.ravel()
        grid.info = info or MapMetaData()
        grid.info.height = arr.shape[0]
        grid.info.width = arr.shape[1]

        return grid


    def run(self, rate: float = 1):
        """
        Periodically publishes the information from the simulator on the defined topics.

        @param rate: The rate at which the topics are published.
        """

        global msg_map

        while not rospy.is_shutdown():

            # Publish messages
            if(msg_map != None):
                self.pub_grid.publish(msg_map)
                self.pub_pos.publish(Point(self.max_point[0], self.max_point[1], 0))


            if rate:
                rospy.sleep(1/rate)




if __name__ == "__main__":
    rospy.init_node('localization_node')

    localization_node = LocalizationNode()
    localization_node.run(rate=1)
